[{"average_distance":0.19151485709659138,"minimum_distance":0.0,"question":"Why do we need to wrap the function call within an anonymous function when writing `movies |> size(1)`?","source":"https://tidierorg.github.io/TidierData.jl/latest/examples/generated/UserGuide/piping - Piping/Julia's built-in  |>  pipe ¤","distance_scores":[0.0,0.0,0.4720670391061452,0.48550724637681164,0.0],"context":"You might have wanted to write `movies |> size(1)` , but because `size(1)` would represent a function  call , we have to wrap the function call within an anonymous function, which is easily accomplished using the `x -> func(x, arg1, arg2)` syntax, where `func()` refers to any function and `arg1` and `arg2` refer to any additional arguments that are needed.","answer":"We need to wrap the function call within an anonymous function because `size(1)` would represent a function call. This is achieved using the `x -> func(x, arg1, arg2)` syntax, where `func()` can be any function and `arg1` and `arg2` are additional arguments needed by the function.","retrieved_contexts":["1. How would we write this using Julia's built-in pipe? ```julia movies   |> \n    x   ->   size ( x ,   1 )``` ```julia 58788```\nYou might have wanted to write `movies |> size(1)` , but because `size(1)` would represent a function  call , we have to wrap the function call within an anonymous function, which is easily accomplished using the `x -> func(x, arg1, arg2)` syntax, where `func()` refers to any function and `arg1` and `arg2` refer to any additional arguments that are needed.\nAnother way we could have accomplished this is to calculate `size` , which returns a tuple of `(rows, columns)` , and then to use an anonymous function to grab the first value. Since we are calculating `size` without any arguments, we can simply write `size` within the pipe. However, to grab the first value using the `x[1]` syntax, we have to define an anonymous function.","2. In this case, the `size()` function returns a tuple of `(rows, columns)` , and if you supply an optional second argument specifying the index of the tuple, it returns only that dimension. In this case, we called `size()` with a second argument of `1` , indicating that we only wanted the function to return the number of rows.\nHow would we write this using Julia's built-in pipe? ```julia movies   |> \n    x   ->   size ( x ,   1 )``` ```julia 58788```\nYou might have wanted to write `movies |> size(1)` , but because `size(1)` would represent a function  call , we have to wrap the function call within an anonymous function, which is easily accomplished using the `x -> func(x, arg1, arg2)` syntax, where `func()` refers to any function and `arg1` and `arg2` refer to any additional arguments that are needed.","3. However, as we start to pipe more and more functions in a single expression, the piped version becomes much easier to reason about.\nOne quick note about Julia's built-in pipe: writing `movies |> nrow()` would  not be considered valid. This is because Julia's built-in pipe always expects a function and  not a function call. Writing `nrow` by itself is  naming the function, whereas writing `nrow()` is  calling the function.\nThis quickly becomes an issue once we want to supply arguments to the function we are calling.","4. Putting it all together, we get this approach to piping:\n```julia movies   |> \n    size   |> \n    x   ->   x [ 1 ]``` ```julia 58788```","5. You might have wanted to write `movies |> size(1)` , but because `size(1)` would represent a function  call , we have to wrap the function call within an anonymous function, which is easily accomplished using the `x -> func(x, arg1, arg2)` syntax, where `func()` refers to any function and `arg1` and `arg2` refer to any additional arguments that are needed.\nAnother way we could have accomplished this is to calculate `size` , which returns a tuple of `(rows, columns)` , and then to use an anonymous function to grab the first value. Since we are calculating `size` without any arguments, we can simply write `size` within the pipe. However, to grab the first value using the `x[1]` syntax, we have to define an anonymous function.\nPutting it all together, we get this approach to piping:"]},{"average_distance":0.21417910447761193,"minimum_distance":0.003731343283582045,"question":"What do the `indices_include` and `keep_empty` options do?","source":"https://tidierorg.github.io/TidierData.jl/latest/reference - Reference/Reference - Exported functions ¤","distance_scores":[0.3694029850746269,0.003731343283582045,0.003731343283582045,0.3619402985074627,0.332089552238806],"context":"`indices_include` : Optional. When set to `true` , adds an index column for each unnested column, which logs the position of each array entry. `keep_empty` : Optional. When set to `true` , rows with empty arrays are kept, not skipped, and unnested as missing. Examples","answer":"When set to `true`, the `indices_include` option adds an index column for each unnested column, which logs the position of each array entry. The `keep_empty` option, when set to `true`, keeps rows with empty arrays and unnests them as missing instead of skipping them.","retrieved_contexts":["1. `@unnest_longer` adds one row per entry of an array or dataframe, lengthening dataframe by flattening the column or columns. ```julia df   =   DataFrame ( x   =   1 : 4 ,   y   =   [[],   [ 1 ,   2 ,   3 ],   [ 4 ,   5 ],   Int []]); \n\n @chain   df   begin \n      @unnest_longer ( y ) \n end``` 5×2 DataFrame Row x y Int64 Any 1 2 1 2\n2 2 3 2 3 4 3 4 5 3 5 If there are rows with empty arrays, `keep_empty` will prevent these rows from being dropped. `include_indices` will add a new column for each flattened column that logs the position of each entry in the array.\n```julia @chain   df   begin \n      @unnest_longer ( y ,   keep_empty   =   true ,   indices_include   =   true ) \n end``` 7×3 DataFrame Row x y y_id Int64 Any Int64 1 1 missing 1 2 2 1 1 3 2 2 2 4 2 3 3 5 3 4 1 6 3 5 2 7 4 missing 1","2. `columns` : Columns to unnest. Can be a column symbols or a range of columns if they align for number of values. `indices_include` : Optional. When set to `true` , adds an index column for each unnested column, which logs the position of each array entry.\n`keep_empty` : Optional. When set to `true` , rows with empty arrays are kept, not skipped, and unnested as missing. Examples\n```julia julia>   df   =   DataFrame ( a = [ 1 ,   2 ],   b = [[ 1 ,   2 ],   [ 3 ,   4 ]],   c = [[ 5 ,   6 ],   [ 7 ,   8 ]]) \n 2×3 DataFrame \n  Row │ a      b       c       \n      │ Int64  Array…  Array…  \n ─────┼─────────────────────── \n    1 │     1  [1, 2]  [5, 6] \n    2 │     2  [3, 4]  [7, 8]","3. `columns` : Columns to unnest. Can be a column symbols or a range of columns if they align for number of values. `indices_include` : Optional. When set to `true` , adds an index column for each unnested column, which logs the position of each array entry.\n`keep_empty` : Optional. When set to `true` , rows with empty arrays are kept, not skipped, and unnested as missing. Examples\n```julia julia>   df   =   DataFrame ( a = [ 1 ,   2 ],   b = [[ 1 ,   2 ],   [ 3 ,   4 ]],   c = [[ 5 ,   6 ],   [ 7 ,   8 ]]) \n 2×3 DataFrame \n  Row │ a      b       c       \n      │ Int64  Array…  Array…  \n ─────┼─────────────────────── \n    1 │     1  [1, 2]  [5, 6] \n    2 │     2  [3, 4]  [7, 8]","4. `stop_in_row_function` is a Function that receives a `TableRow` and returns a `Bool` indicating if the end of the table was reached. Example for `stop_in_row_function` : ```julia function stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend```\n`keep_empty_rows` determines whether rows where all column values are equal to `missing` are kept ( `true` ) or dropped ( `false` ) from the resulting table. `keep_empty_rows` never affects the  bounds of the table; the number of rows read from a sheet is only affected by, `first_row` , `stop_in_empty_row` and `stop_in_row_function` (if specified).\n`keep_empty_rows` is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.","5. `stop_in_empty_row` is a boolean indicating whether an empty row marks the end of the table. If `stop_in_empty_row=false` , the iterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is `stop_in_empty_row=true` . Empty rows may be returned by the iterator when `stop_in_empty_row=false` .\n`keep_empty_rows` determines whether rows where all column values are equal to `missing` are kept ( `true` ) or skipped ( `false` ) by the row iterator. `keep_empty_rows` never affects the  bounds of the iterator; the number of rows read from a sheet is only affected by `first_row` , `stop_in_empty_row` and `stop_in_row_function` (if specified).\nExample code: ```julia for r in XLSX.eachtablerow(sheet)\n    # r is a `TableRow`. Values are read using column labels or numbers.\n    rn = XLSX.row_number(r) # `TableRow` row number.\n    v1 = r[1] # will read value at table column 1.\n    v2 = r[:COL_LABEL2] # will read value at column labeled `:COL_LABEL2`.\nend``` See also  `XLSX.gettable` . source"]},{"average_distance":0.3755189122730889,"minimum_distance":0.20525059665871126,"question":"What does the `@slice_tail` macro do and what arguments does it accept?","source":"https://tidierorg.github.io/TidierData.jl/latest/reference - Reference/Reference - Exported functions ¤","distance_scores":[0.20525059665871126,0.20525059665871126,0.5369928400954653,0.3787878787878788,0.5513126491646778],"context":"source #  `TidierData.@slice_tail` —  Macro . ```julia @slice_tail ( df ;   n ,   prop )``` Retrieve rows from the end of a DataFrame or GroupedDataFrame. Arguments `df` : The source data frame or grouped data frame from which to slice rows. `prop` : The proportion of rows to slice. `n` : An optional integer argument to specify the number of rows at the beginning of the dataframe to retrieve. Defaults to 1. Examples","answer":"The `@slice_tail` macro retrieves rows from the end of a DataFrame or GroupedDataFrame. It accepts the following arguments:\n- `df`: The source data frame or grouped data frame from which to slice rows.\n- `prop`: The proportion of rows to slice.\n- `n`: An optional integer argument to specify the number of rows at the beginning of the dataframe to retrieve. Defaults to 1.","retrieved_contexts":["1. julia >   @chain   df   begin   \n           @slice_sample ( prop   =   0.5 ,   replace   =   true ) \n         end \n 5 × 2   DataFrame \n   Row   │   a        b       \n       │   Int64    Int64   \n ─────┼────────────── \n     1   │      10       20 \n     2   │       4       14 \n     3   │       9       19 \n     4   │       9       19 \n     5   │       8       18```\nsource #  `TidierData.@slice_tail` —  Macro . ```julia @slice_tail ( df ;   n ,   prop )``` Retrieve rows from the end of a DataFrame or GroupedDataFrame. Arguments `df` : The source data frame or grouped data frame from which to slice rows. `prop` : The proportion of rows to slice.\njulia>   @chain   df   begin \n           @slice_tail ( n   =   3 ) \n         end   \n 3×3 DataFrame \n  Row │ a          b         c          \n      │ Float64?   Float64?  Float64?   \n ─────┼──────────────────────────────── \n    1 │ missing         5.0  missing    \n    2 │       5.0       7.0        5.0 \n    3 │       6.0       7.0        6.0","2. julia >   @chain   df   begin   \n           @slice_sample ( prop   =   0.5 ,   replace   =   true ) \n         end \n 5 × 2   DataFrame \n   Row   │   a        b       \n       │   Int64    Int64   \n ─────┼────────────── \n     1   │      10       20 \n     2   │       4       14 \n     3   │       9       19 \n     4   │       9       19 \n     5   │       8       18```\nsource #  `TidierData.@slice_tail` —  Macro . ```julia @slice_tail ( df ;   n ,   prop )``` Retrieve rows from the end of a DataFrame or GroupedDataFrame. Arguments `df` : The source data frame or grouped data frame from which to slice rows. `prop` : The proportion of rows to slice.\njulia>   @chain   df   begin \n           @slice_tail ( n   =   3 ) \n         end   \n 3×3 DataFrame \n  Row │ a          b         c          \n      │ Float64?   Float64?  Float64?   \n ─────┼──────────────────────────────── \n    1 │ missing         5.0  missing    \n    2 │       5.0       7.0        5.0 \n    3 │       6.0       7.0        6.0","3. Grouped data frames can be ungrouped using `@ungroup()` . If you apply a new `@group_by()` macro to an already-grouped data frame, then the newly specified groups override the old ones.\nWhen we use the `@chain` macro, we are taking advantage of the fact that Julia macros can either be called using parentheses syntax, where each argument is separated by a comma, or they can be called with a spaced syntax where no parentheses are used.\nIn the case of Tidier.jl macros, we always use the parentheses syntax, which makes is very easy to use the spaced syntax when working with `@chain` .","4. How can functions pass arguments to a TidierDB chain? In short, you have to use a macro instead in conjuction with `@interpolate`","5. For `@slice()` , any valid `UnitRange` of integers is considered valid; this is not the case for `@select()` or `across()` .\nRemember: Just like every other `TidierData.jl` top-level macro, `@slice()` respects group. This means that in a grouped data frame, `@slice(1:2)` will select the first 2 rows  from each group .\n```julia using   TidierData \n\n df   =   DataFrame ( row_num   =   1 : 10 , \n                 a   =   string . ( repeat ( 'a' : 'e' ,   inner   =   2 )), \n                 b   =   [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 ])``` 10×3 DataFrame Row row_num a b Int64 String Int64 1 1 a 1 2 2 a 1 3 3 b 1"]},{"average_distance":0.23649635036496347,"minimum_distance":0.0024330900243308973,"question":"How can you optimize the querying process with `db_table` when using OAuth tokens that might expire?","source":"https://tidierorg.github.io/TidierDB.jl/latest/examples/generated/UserGuide/Snowflake - Using Snowflake/Connecting ¤","distance_scores":[0.0024330900243308973,0.0024330900243308973,0.22384428223844277,0.46958637469586373,0.4841849148418491],"context":"Since each time `db_table` runs, it runs a query to pull the metadata, you may choose to use run `db_table` and save the results, and use these results with `from_query()`   This will reduce the number of queries to your database  Allow you to build a a SQL query and `@show_query` even if the OAuth  token has expired. To `@collect` you will have to reconnect and rerun db table if your OAuth token has expired","answer":"To optimize the querying process with `db_table` when using OAuth tokens that might expire, you can run `db_table` and save the results. Then, use these saved results with `from_query()`. This approach reduces the number of queries to your database and allows you to build a SQL query and use `@show_query` even if the OAuth token has expired. However, to `@collect` the data, you will need to reconnect and rerun `db_table` if your OAuth token has expired.","retrieved_contexts":["1. Connection is established with the `connect` function as shown below. Connection requires 5 items as strings Account Identifier OAuth token Database Name Schema Name Compute Warehouse name Two things to note: Your OAuth Token may frequently expire, which may require you to rerun your connection line.\nSince each time `db_table` runs, it runs a query to pull the metadata, you may choose to use run `db_table` and save the results, and use these results with `from_query()`   This will reduce the number of queries to your database  Allow you to build a a SQL query and `@show_query` even if the OAuth  token has expired.\nTo `@collect` you will have to reconnect and rerun db table if your OAuth token has expired","2. Since each time `db_table` runs, it runs a query to pull the metadata, you may choose to use run `db_table` and save the results, and use these results with `from_query()`   This will reduce the number of queries to your database  Allow you to build a a SQL query and `@show_query` even if the OAuth  token has expired.\nTo `@collect` you will have to reconnect and rerun db table if your OAuth token has expired\n```julia set_sql_mode ( snowflake ()) \n ac_id   =   \"string_id\" \n token   =   \"OAuth_token_string\" \n con   =   connect ( :snowflake ,   ac_id ,   token ,   \"DEMODB\" ,   \"PUBLIC\" ,   \"COMPUTE_WH\" ) \n # After connection is established, a you may begin querying.","3. Connection is established with the `connect` function as shown below. Connection requires 5 items as strings Account Instance :  how to find your instance OAuth token :  how to generate your token Database Name Schema Name warehouse_id\nOne thing to note, Since each time `db_table` runs, it runs a query to pull the metadata, you may choose to use run `db_table` and save the results, and use these results with `from_query()` . This will reduce the number of queries to your database and is illustrated below.\n```julia set_sql_mode ( databricks ()) \n instance_id   =   \"string_id\" \n token   \"string_token\" \n warehouse_id   =   \"e673cd4f387f964a\" \n con   =   connect ( :databricks ,   instance_id ,   token ,   \"DEMODB\" ,   \"PUBLIC\" ,   warehouse_id ) \n # After connection is established, a you may begin querying.","4. Throughout TidierDB, each time `db_table` is called, it queries the databases to get the metadata. Consider how AWS Athena logs queries, a user may want to reduce the number of queries. This can be done saving the results of `db_table` , and then using from_query with those results for furthe queries as shown below.\n```julia mtcars   =   db_table ( AWS_GLOBAL_CONFIG [],   \"demodb.mtcars\" ,   athena_params ) \n @chain   from_query ( mtcars )   begin \n      @filter ( cyl   >   4 ) \n      @group_by ( cyl ) \n      @summarize ( mpg   =   mean ( mpg )) \n     #@show_query \n      @collect \n end```","5. If you are working with a backend where compute cost is important, it will be important to minimize using `db_table` as this will requery for metadata each time. Compute costs are relevant to backends such as AWS, databricks and Snowflake.\nTo do this, save the results of `db_table` and use them with `from_query` . Using `from_query` pulls the relevant information (metadata, con, etc) from the mutable SQLquery struct, allowing you to repeatedly query and collect the table without requerying for the metadata each time"]},{"average_distance":0.09867377371660638,"minimum_distance":0.0,"question":"What is TidierDB.jl and its main goal?","source":"https://tidierorg.github.io/TidierDB.jl/latest - Home/What is TidierDB.jl? ¤","distance_scores":[0.07516339869281041,0.07516339869281041,0.34304207119741104,0.0,0.0],"context":"TiderDB.jl is a 100% Julia implementation of the dbplyr R package, and similar to Python's ibis package. The main goal of TidierDB.jl is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.","answer":"TidierDB.jl is a 100% Julia implementation of the dbplyr R package, and similar to Python's ibis package. The main goal of TidierDB.jl is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.","retrieved_contexts":["1. TidierDB.jl is a 100% Julia implementation of the R package dbplyr in Julia and similar to Python's ibis package. Its main goal is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.","2. TidierDB.jl is a 100% Julia implementation of the R package dbplyr in Julia and similar to Python's ibis package. Its main goal is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.","3. A number of macro-based data analysis packages have emerged as extensions of DataFrames.jl to make data analysis syntax less verbose, including DataFramesMeta.jl, Query.jl, and DataFrameMacros.jl. All of these packages have their strengths, and each of these served as an inspiration towards the creation of Tidier.jl.\nWhat sets Tidier.jl apart is that it borrows the design of the tried-and-widely-adopted tidyverse and brings it to Julia. Our goal is to make data analysis code as easy and readable as possible.\nIn our view, the reason you should use Tidier.jl is because of the richness, consistency, and thoroughness of the design made possible by bringing together two powerful tools: DataFrames.jl and the tidyverse. In Tidier.jl, nearly every possible transformation on data frames (e.g., aggregating, pivoting, nesting, and joining) can be accomplished using a consistent syntax.","4. TiderDB.jl is a 100% Julia implementation of the dbplyr R package, and similar to Python's ibis package. The main goal of TidierDB.jl is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory.","5. TiderDB.jl is a 100% Julia implementation of the dbplyr R package, and similar to Python's ibis package. The main goal of TidierDB.jl is to bring the syntax of Tidier.jl to multiple SQL backends, making it possible to analyze data directly on databases without needing to copy the entire database into memory."]},{"average_distance":0.26402559055118113,"minimum_distance":0.0024038461538461453,"question":"What does the `if_else` method in TidierData return when the condition is `true`, `false`, or `missing`?","source":"https://tidierorg.github.io/TidierData.jl/latest/reference/ - Reference/Reference - Exported functions ¤","distance_scores":[0.37259615384615385,0.47637795275590555,0.0024038461538461453,0.0024038461538461453,0.46634615384615385],"context":"source #  `TidierData.if_else` —  Method . ```julia if_else ( condition ,   yes ,   no ,   [ miss ])``` Return the `yes` value if the `condition` is `true` and the `no` value if the `condition` is `false` . If `miss` is specified, then the provided `miss` value is returned when the `condition` contains a `missing` value. If `miss` is not specified, then the returned value is an explicit `missing` value. Arguments","answer":"The `if_else` method in TidierData returns the `yes` value if the condition is `true`, the `no` value if the condition is `false`, and if `miss` is specified, then the provided `miss` value is returned when the condition contains a `missing` value. If `miss` is not specified, the returned value is an explicit `missing` value.","retrieved_contexts":["1. Why do we need another `if_else()` function if base Julia already comes with an `ifelse()` function. Similar to R, the base Julia implementation of `if_else()` does not include a way to designate what value to return if the enclosed vector contains a missing value.\nAdditionally, the base Julia implementation of `ifelse()` produces an error if presented with a `missing` value in the condition. The TidierData.jl `if_else()` can handle missing values and includes an optional 4th argument that is used to designate what to return in the event of a `missing`` value for the condition. Let's take a look at some examples.\n```julia using   TidierData \n\n df   =   DataFrame ( a   =   [ 1 ,   2 ,   missing ,   4 ,   5 ])``` 5×1 DataFrame Row a Int64? 1 1 2 2 3 missing 4 4 5 5 Here, we have created a `DataFrame` containing a single column `a` with 5 values, for which the 3rd value is missing.","2. TidierData.jl   Conditionals       Initializing search    TidierData.jl\nConditionals   Conditionals   Table of contents     if_else()    case_when()    Do these functions work outside of TidierData.jl?\nDo these functions work outside of TidierData.jl?","3. 5   │      25        5       15```\nsource #  `TidierData.if_else` —  Method . ```julia if_else ( condition ,   yes ,   no ,   [ miss ])```\nReturn the `yes` value if the `condition` is `true` and the `no` value if the `condition` is `false` . If `miss` is specified, then the provided `miss` value is returned when the `condition` contains a `missing` value. If `miss` is not specified, then the returned value is an explicit `missing` value. Arguments","4. 5   │      25        5       15```\nsource #  `TidierData.if_else` —  Method . ```julia if_else ( condition ,   yes ,   no ,   [ miss ])```\nReturn the `yes` value if the `condition` is `true` and the `no` value if the `condition` is `false` . If `miss` is specified, then the provided `miss` value is returned when the `condition` contains a `missing` value. If `miss` is not specified, then the returned value is an explicit `missing` value. Arguments","5. Although `if_else()` is convenient when evaluating a single condition, it can be cumbersome when evaluating multiple conditions because subsequent conditions need to be nested within the `no` condition for the preceding argument. For situations where multiple conditions need to be evaluated, `case_when()` is more convenient.\nLet's first consider a similar example from above and recreate it using `case_when()` . The following code creates a column `b` that assigns a value of 3 if `a >= 3` and otherwise leaves the value unchanged. ```julia @chain   df   begin \n    @mutate ( b   =   case_when ( a   >=   3    =>    3 , \n                          true      =>    a )) \n end``` 5×2 DataFrame"]},{"average_distance":0.5255187794661479,"minimum_distance":0.45723684210526316,"question":"What is the purpose of the `@nest` macro in the `TidierData` package and how is it used?","source":"https://tidierorg.github.io/TidierData.jl/latest/reference - Reference/Reference - Exported functions ¤","distance_scores":[0.5541125541125541,0.5541125541125541,0.6048951048951049,0.45723684210526316,0.45723684210526316],"context":"source #  `TidierData.@nest` —  Macro . ```julia @nest ( df ,   new_column   =   nesting_columns )``` Multiple columns are nested into one or more new columns in a DataFrame. Arguments `df` : A DataFrame `new_column` : New column name `nesting_columns` : Columns to be nested into the new_column Examples","answer":"The `@nest` macro in the `TidierData` package is used to nest multiple columns into one or more new columns in a DataFrame. It takes three arguments: `df` (a DataFrame), `new_column` (the name of the new column), and `nesting_columns` (the columns to be nested into the new column).","retrieved_contexts":["1. Home   Home   Table of contents     What is TidierData.jl?    Installation    What macros and functions does TidierData.jl support?    Example    What’s new    What's missing\nWhat macros and functions does TidierData.jl support?","2. Home   Home   Table of contents     What is TidierData.jl?    Installation    What macros and functions does TidierData.jl support?    Example    What’s new    What's missing\nWhat macros and functions does TidierData.jl support?","3. :root{--md-text-font:\"Lato\";--md-code-font:\"Roboto Mono\"}\nTidierData.jl   Nesting       Initializing search    TidierData.jl\nNesting   Nesting   Table of contents     @nest    @unnest_longer    @unnest_wider    Unnesting nested Dataframes with different lengths which contains arrays","4. To support R-style programming, `TidierData.jl` is implemented using macros. This is because macros are able to \"capture\" the code before executing it, which allows the package to support R-like \"tidy expressions\" that would otherwise not be considered valid Julia code. TidierData.jl currently supports the following top-level macros: Top-level macros: `@glimpse()`\n`@select()` and `@distinct()` `@rename()` and `@rename_with()` `@mutate()` and `@transmute()` `@summarize()` and `@summarise()` `@filter()` `@slice()` , `@slice_sample()` , `@slice_min()` , `@slice_max()` , `@slice_head()` , and `@slice_tail()` `@group_by()` and `@ungroup()` `@arrange()` `@relocate()` `@pull()` `@count()` and `@tally()`","5. To support R-style programming, `TidierData.jl` is implemented using macros. This is because macros are able to \"capture\" the code before executing it, which allows the package to support R-like \"tidy expressions\" that would otherwise not be considered valid Julia code. TidierData.jl currently supports the following top-level macros: Top-level macros: `@glimpse()`\n`@select()` and `@distinct()` `@rename()` and `@rename_with()` `@mutate()` and `@transmute()` `@summarize()` and `@summarise()` `@filter()` `@slice()` , `@slice_sample()` , `@slice_min()` , `@slice_max()` , `@slice_head()` , and `@slice_tail()` `@group_by()` and `@ungroup()` `@arrange()` `@relocate()` `@pull()` `@count()` and `@tally()`"]},{"average_distance":0.407324016563147,"minimum_distance":0.0,"question":"How is a line plot created in Julia using ggplot and DataFrame with specific labels and theme?","source":"https://tidierorg.github.io/TidierPlots.jl/latest/examples/generated/UserGuide/gettingstarted - Getting Started/geom_path  and  geom_line ¤","distance_scores":[0.0,0.5942028985507246,0.5942028985507246,0.42559523809523814,0.42261904761904767],"context":"```julia x_values   =   1 : 10 ; \n y_values   =   x_values   .^   2 ; \n df_line   =   DataFrame ( X   =   x_values ,   Y   =   y_values ); \n ggplot ( df_line )   + \n      geom_line ( @aes ( x   =   X ,   y   =   Y ))   + \n      labs ( title   =   \"Line Plot Example\" ,   x   =   \"X axis\" ,   y   =   \"Y axis\" ) + \n      theme_dark ()```","answer":"A line plot is created in Julia by first defining the x and y values using the code `x_values = 1:10` and `y_values = x_values .^ 2`. These values are then stored in a DataFrame using `df_line = DataFrame(X = x_values, Y = y_values)`. The ggplot function is used to create the plot with `ggplot(df_line)`, and `geom_line(@aes(x = X, y = Y))` adds the line geometry to the plot. Labels for the title, x axis, and y axis are added with `labs(title = \"Line Plot Example\", x = \"X axis\", y = \"Y axis\")`. Finally, the theme is set to dark using `theme_dark()`. ","retrieved_contexts":["1. The `geom_path` and `geom_line` are used to create line plots. `geom_path` connects the data points in the order they appear in the data, while `geom_line` connects the data points in order of the x-values.\n```julia x_values   =   1 : 10 ; \n y_values   =   x_values   .^   2 ; \n df_line   =   DataFrame ( X   =   x_values ,   Y   =   y_values ); \n ggplot ( df_line )   + \n      geom_line ( @aes ( x   =   X ,   y   =   Y ))   + \n      labs ( title   =   \"Line Plot Example\" ,   x   =   \"X axis\" ,   y   =   \"Y axis\" ) + \n      theme_dark ()```","2. Plot Customizations - Julia Data Science\n@font-face {\n    font-family: JuliaMono-Regular;\n    src: url(\"/JuliaMono-Regular.woff2\");\n  }","3. Plot Customizations - Julia Data Science\n@font-face {\n    font-family: JuliaMono-Regular;\n    src: url(\"/JuliaMono-Regular.woff2\");\n  }","4. To define a brand new style, you simply construct one or more of the fields and assign it using the keyword argument `Style` constructor. For example, this is how the `ggplot` style is defined (as of time of writing):\n```julia ggplot = let\n    axis = attr(showgrid=true, gridcolor=\"white\", linewidth=1.0,\n                linecolor=\"white\", titlefont_color=\"#555555\",\n                titlefont_size=14, ticks=\"outside\",\n                tickcolor=\"#555555\"\n                )\n    layout = Layout(plot_bgcolor=\"#E5E5E5\",\n                    paper_bgcolor=\"white\",\n                    font_size=10,\nxaxis=axis,\n                    yaxis=axis,\n                    titlefont_size=14)","5. Every Block such as `Axis` , `Legend` , `Colorbar` , etc. can be themed by using its type name as a key in your theme. Here is how you could define a simple ggplot-like style for your axes: julia\n```julia ggplot_theme  =  Theme ( \n     Axis  =  ( \n         backgroundcolor  =  :gray90 , \n         leftspinevisible  =  false , \n         rightspinevisible  =  false , \n         bottomspinevisible  =  false , \n         topspinevisible  =  false , \n         xgridcolor  =  :white , \n         ygridcolor  =  :white , \n     ) \n ) \n \n with_theme (example_plot, ggplot_theme)```"]},{"average_distance":0.25816993464052285,"minimum_distance":0.009803921568627416,"question":"How does the `ggplot` code snippet visualize the data using the `dodge` aesthetic?","source":"https://tidierorg.github.io/TidierPlots.jl/latest/reference - API/Reference - Exported functions ¤","distance_scores":[0.009803921568627416,0.10457516339869277,0.2941176470588235,0.4673202614379085,0.41503267973856206],"context":"# dodge using the dodge aesthetic \n ggplot ( df )   + \n      geom_col ( @aes ( x   =   species ,   y   =   mean_bill_length_mm ,   dodge   =   sex )) \n\n # color based on grouping variable \n ggplot ( df )   + \n      geom_col ( @aes ( x   =   species ,   y   =   mean_bill_length_mm ,   color   =   sex ))```","answer":"The `ggplot` code snippet visualizes the data by using the `dodge` aesthetic to show bars for different `sex` values side by side for each `species` on the x-axis, with `mean_bill_length_mm` on the y-axis.","retrieved_contexts":["1. ```julia df   =   @chain   penguins   begin \n      @group_by ( species ,   sex ) \n      @summarize ( mean_bill_length_mm   =   mean ( bill_length_mm )) \n      @ungroup () \n end \n\n ggplot ( df )   + \n      geom_col ( @aes ( x   =   species ,   y   =   mean_bill_length_mm ))\n# dodge using the group and position arguments \n ggplot ( df )   + \n      geom_col ( @aes ( x   =   species ,   y   =   mean_bill_length_mm ,   group   =   sex ), \n               position = \"dodge\" ) \n\n # dodge using the dodge aesthetic \n ggplot ( df )   + \n      geom_col ( @aes ( x   =   species ,   y   =   mean_bill_length_mm ,   dodge   =   sex ))\n# color based on grouping variable \n ggplot ( df )   + \n      geom_col ( @aes ( x   =   species ,   y   =   mean_bill_length_mm ,   color   =   sex ))```","2. sex mean_bill_length_mm String15 String7 Float64 1 Adelie male 40.3904 2 Adelie female 37.2575 3 Gentoo female 45.5638 4 Gentoo male 49.4738 5 Chinstrap female 46.5735 6 Chinstrap male 51.0941\n```julia ggplot ( df ,   @aes ( x   =   species ,   y   =   mean_bill_length_mm ))   + \n      geom_col ()``` dodge using the group and position arguments ```julia ggplot ( df ,   @aes ( x   =   species ,   y   =   mean_bill_length_mm ,   group   =   sex ))   + \n      geom_col ( position = \"dodge\" )``` dodge using the dodge aesthetic\n```julia ggplot ( df ,   @aes ( x   =   species ,   y   =   mean_bill_length_mm ,   dodge   =   sex ))   + \n      geom_col ()``` color based on grouping variable ```julia ggplot ( df ,   @aes ( x   =   species ,   y   =   mean_bill_length_mm ,   color   =   sex ))   + \n      geom_col ()``` This page was generated using  Literate.jl . Back to top","3. ```julia using   TidierPlots \n using   DataFrames \n using   PalmerPenguins \n\n penguins   =   dropmissing ( DataFrame ( PalmerPenguins . load ()));``` vertical bar plot ```julia ggplot ( penguins ,   @aes ( x   =   species ))   + \n      geom_bar ()``` horizontal bar plot ```julia ggplot ( penguins ,   @aes ( y   =   species ))   + \n      geom_bar ()```\nposition dodge ```julia ggplot ( penguins ,   @aes ( x   =   species ,   color = sex ,   dodge = sex ))   + \n      geom_bar ()``` alternative way to dodge ```julia ggplot ( penguins ,   @aes ( x   =   species ,   color   =   sex ,   group   =   sex ))   + \n      geom_bar ( position = \"dodge\" )``` This page was generated using  Literate.jl . Back to top\nPrevious  Home Next  geom_boxplot Made with Material for MkDocs","4. `clip_planes` = `automatic` — TODO: docs `color` = `@inherit patchcolor` —  No docs available. `color_over_background` = `automatic` —  No docs available. `color_over_bar` = `automatic` —  No docs available.\n`direction` = `:y` — Controls the direction of the bars, can be `:y` (vertical) or `:x` (horizontal). `dodge` = `automatic` —  No docs available. `dodge_gap` = `0.03` —  No docs available.\n`fillto` = `automatic` — Controls the baseline of the bars. This is zero in the default `automatic` case unless the barplot is in a log-scaled `Axis` . With a log scale, the automatic default is half the minimum value because zero is an invalid value for a log scale. `flip_labels_at` = `Inf` —  No docs available.","5. `color_over_bar` = `automatic` —  No docs available. `colormap` = `@inherit colormap :viridis` — Sets the colormap that is sampled for numeric `color` s. `PlotUtils.cgrad(...)` , `Makie.Reverse(any_colormap)` can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call `Makie.available_gradients()` .\n`direction` = `:y` — Controls the direction of the bars, can be `:y` (vertical) or `:x` (horizontal). `dodge` = `automatic` —  No docs available. `dodge_gap` = `0.03` —  No docs available.\n`fillto` = `automatic` — Controls the baseline of the bars. This is zero in the default `automatic` case unless the barplot is in a log-scaled `Axis` . With a log scale, the automatic default is half the minimum value because zero is an invalid value for a log scale. `flip_labels_at` = `Inf` —  No docs available."]},{"average_distance":0.41234182220816207,"minimum_distance":0.0021551724137931494,"question":"What is the purpose of the `@full_join` macro in TidierDB, and what is a key difference in its usage compared to TidierData.jl?","source":"https://tidierorg.github.io/TidierDB.jl/latest/reference - Reference/Reference - Exported functions ¤","distance_scores":[0.0021551724137931494,0.6077586206896552,0.6077586206896552,0.42201834862385323,0.42201834862385323],"context":"source #  `TidierDB.@full_join` —  Macro . ```julia @inner_join ( sql_query ,   join_table ,   new_table_col ,   orignal_table_col )``` Perform an full join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different Arguments `sql_query` : The primary SQL query to operate on.","answer":"The purpose of the `@full_join` macro in TidierDB is to perform a full join between two SQL queries based on a specified condition. A key difference in its usage compared to TidierData.jl is that SQL does not drop the joining column, so it is preferable for the names to be different for metadata storage.","retrieved_contexts":["1. 2×2 DataFrame \n  Row │ groups   mean      \n      │ String?  Float64?  \n ─────┼─────────────────── \n    1 │ aa            0.6 \n    2 │ bb            0.5```\nsource #  `TidierDB.@full_join` —  Macro . ```julia @inner_join ( sql_query ,   join_table ,   new_table_col ,   orignal_table_col )```\nPerform an full join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different Arguments `sql_query` : The primary SQL query to operate on.","2. julia>   @chain   df   begin \n           @filter ( b   in   ( 1 ,   3 )) \n         end \n 2×3 DataFrame \n  Row │ a     b      c      \n      │ Char  Int64  Int64  \n ─────┼──────────────────── \n    1 │ a         1     11 \n    2 │ c         3     13```\nsource #  `TidierData.@full_join` —  Macro . ```julia @full_join ( df1 ,   df2 ,   [ by ])``` Perform a full join on `df1` and `df2` with an optional `by` . Arguments `df1` : A DataFrame. `df2` : A DataFrame.\n```julia julia>   df1   =   DataFrame ( a   =   [ \"a\" ,   \"b\" ],   b   =   1 : 2 ); \n\n julia>   df2   =   DataFrame ( a   =   [ \"a\" ,   \"c\" ],   c   =   3 : 4 );","3. julia>   @chain   df   begin \n           @filter ( b   in   ( 1 ,   3 )) \n         end \n 2×3 DataFrame \n  Row │ a     b      c      \n      │ Char  Int64  Int64  \n ─────┼──────────────────── \n    1 │ a         1     11 \n    2 │ c         3     13```\nsource #  `TidierData.@full_join` —  Macro . ```julia @full_join ( df1 ,   df2 ,   [ by ])``` Perform a full join on `df1` and `df2` with an optional `by` . Arguments `df1` : A DataFrame. `df2` : A DataFrame.\n```julia julia>   df1   =   DataFrame ( a   =   [ \"a\" ,   \"b\" ],   b   =   1 : 2 ); \n\n julia>   df2   =   DataFrame ( a   =   [ \"a\" ,   \"c\" ],   c   =   3 : 4 );","4. Key Differences from TidierData.jl - TidierDB.jl\n:root{--md-text-font:\"Lato\";--md-code-font:\"Roboto Mono\"}","5. Key Differences from TidierData.jl - TidierDB.jl\n:root{--md-text-font:\"Lato\";--md-code-font:\"Roboto Mono\"}"]},{"average_distance":0.578115663679044,"minimum_distance":0.460093896713615,"question":"What does the `@pull` macro in `Tidier` do, and what arguments does it take?","source":"https://tidierorg.github.io/Tidier.jl/stable/reference - Reference/Reference - Exported functions ¤","distance_scores":[0.460093896713615,0.6338028169014085,0.6338028169014085,0.5378787878787878,0.625],"context":"#  `Tidier.@pull` —  Macro . ```julia @pull ( df ,   column )``` Pull (or extract) a column as a vector. Arguments `df` : A DataFrame. `column` : A single column, referred to either by its name or number. Examples","answer":"The `@pull` macro in `Tidier` is used to pull (or extract) a column as a vector from a DataFrame. It takes two arguments: `df`, which is a DataFrame, and `column`, which is a single column referred to either by its name or number.","retrieved_contexts":["1. To write a macro that will take arguments and pass them to a TidierDB chain, there are 3 steps: Write macro with the desired argument(s), and, after the quote, add the chain. Arguments to be changed/interpolated must be prefixed with `!!`\nUse `@interpolate` to make these arguemnts accessible to the chain. `@interpolate` takes touples as argument (one for the `!!` name, and one for the actual content you want the chain to use) Run `@interpolate` and then the chain macro sequentially","2. Home   Home   Table of contents     What is TidierData.jl?    Installation    What macros and functions does TidierData.jl support?    Example    What’s new    What's missing\nWhat macros and functions does TidierData.jl support?","3. Home   Home   Table of contents     What is TidierData.jl?    Installation    What macros and functions does TidierData.jl support?    Example    What’s new    What's missing\nWhat macros and functions does TidierData.jl support?","4. How can functions pass arguments to a TidierDB chain? In short, you have to use a macro instead in conjuction with `@interpolate`","5. Writing Functions/Macros with TidierDB Chains - TidierDB.jl\n:root{--md-text-font:\"Lato\";--md-code-font:\"Roboto Mono\"}"]},{"average_distance":0.4743326488706366,"minimum_distance":0.08008213552361398,"question":"What does the prefix `~` do in the context of using Tidier.jl for defining custom functions?","source":"https://tidierorg.github.io/Tidier.jl/stable/examples/generated/UserGuide/autovec - Auto-vectorization","distance_scores":[0.5338809034907597,0.5338809034907597,0.08008213552361398,0.6119096509240247,0.6119096509240247],"context":"This \"auto-vectorization\" makes working with Tidier.jl more R-like and convenient. However, if you ever define your own function and try to use it, Tidier.jl may unintentionally vectorize it for you. To prevent auto-vectorization, you can prefix your function with a `~` . ```julia using   Tidier \n using   RDatasets \n\n df   =   DataFrame ( a   =   repeat ( 'a' : 'e' ,   inner   =   2 ),   b   =   [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 ],   c   =   11 : 20 )``` 10×3 DataFrame Row a b","answer":"In the context of using Tidier.jl, prefixing a custom function with `~` prevents it from being auto-vectorized, which makes working with Tidier.jl more R-like and convenient.","retrieved_contexts":["1. An example of where this issue commonly causes errors is when centering a variable. To create a new column `a` that centers the column `b` , `TidierData.jl` lets you simply write `a = b - mean(b)` exactly as you would in R.\nThis works because `TidierData.jl` knows to  not vectorize `mean()` while also recognizing that `-`  should be vectorized such that this expression is rewritten in `DataFrames.jl` as `:b => (b -> b .- mean(b)) => :a` . For any user-defined function that you want to \"mark\" as being non-vectorized, you can prefix it with a `~` .\nFor example, a function `new_mean()` , if it had the same functionality as `mean()`  would normally get vectorized by `TidierData.jl` unless you write it as `~new_mean()` .","2. An example of where this issue commonly causes errors is when centering a variable. To create a new column `a` that centers the column `b` , `TidierData.jl` lets you simply write `a = b - mean(b)` exactly as you would in R.\nThis works because `TidierData.jl` knows to  not vectorize `mean()` while also recognizing that `-`  should be vectorized such that this expression is rewritten in `DataFrames.jl` as `:b => (b -> b .- mean(b)) => :a` . For any user-defined function that you want to \"mark\" as being non-vectorized, you can prefix it with a `~` .\nFor example, a function `new_mean()` , if it had the same functionality as `mean()`  would normally get vectorized by `TidierData.jl` unless you write it as `~new_mean()` .","3. :cat_collapse, :cat_lump_min, :cat_lump_prop, :categorical, :as_categorical, :is_categorical, :unique, :iqr]\"```\nThis \"auto-vectorization\" makes working with TidierData.jl more R-like and convenient. However, if you ever define your own function and try to use it, TidierData.jl may unintentionally vectorize it for you. To prevent auto-vectorization, you can prefix your function with a `~` .\n```julia df   =   DataFrame ( a   =   repeat ( 'a' : 'e' ,   inner   =   2 ),   b   =   [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 4 ],   c   =   11 : 20 )``` 10×3 DataFrame Row a b c Char Int64 Int64 1 a 1 11 2 a 1 12 3 b 1 13 4 b 2 14 5 c 2 15 6 c 2 16","4. This works because `TidierData.jl` knows to  not vectorize `mean()` while also recognizing that `-`  should be vectorized such that this expression is rewritten in `DataFrames.jl` as `:b => (b -> b .- mean(b)) => :a` . For any user-defined function that you want to \"mark\" as being non-vectorized, you can prefix it with a `~` .\nFor example, a function `new_mean()` , if it had the same functionality as `mean()`  would normally get vectorized by `TidierData.jl` unless you write it as `~new_mean()` .","5. This works because `TidierData.jl` knows to  not vectorize `mean()` while also recognizing that `-`  should be vectorized such that this expression is rewritten in `DataFrames.jl` as `:b => (b -> b .- mean(b)) => :a` . For any user-defined function that you want to \"mark\" as being non-vectorized, you can prefix it with a `~` .\nFor example, a function `new_mean()` , if it had the same functionality as `mean()`  would normally get vectorized by `TidierData.jl` unless you write it as `~new_mean()` ."]},{"average_distance":0.522340425531915,"minimum_distance":0.4414893617021277,"question":"What does the right join operation do, and what arguments does it require?","source":"https://tidierorg.github.io/Tidier.jl/stable/reference - Reference/Reference - Exported functions ¤","distance_scores":[0.4414893617021277,0.601063829787234,0.5824468085106382,0.48404255319148937,0.5026595744680851],"context":"```julia @right_join ( df1 ,   df2 ,   [ by ])``` Perform a right join on `df1` and `df` with an optional `by` . Arguments `df1` : A DataFrame. `df2` : A DataFrame. `by` : An optional column or tuple of columns. `by` supports interpolation of individual columns. If `by` is not supplied, then it will be inferred from shared names of columns between `df1` and `df2` . Examples","answer":"The right join operation performs a right join on `df1` and `df2` with an optional `by`. The arguments required are: `df1` (a DataFrame), `df2` (a DataFrame), and `by` (an optional column or tuple of columns, which can be interpolated from individual columns or inferred from shared column names if not provided).","retrieved_contexts":["1. In relational database theory, this operation is generally referred to as a join. The columns used to determine which rows should be combined during a join are called keys. The following functions are provided to perform seven kinds of joins: `innerjoin` : the output contains rows for values of the key that exist in all passed data frames.\n`leftjoin` : the output contains rows for values of the key that exist in the first (left) argument, whether or not that value exists in the second (right) argument. `rightjoin` : the output contains rows for values of the key that exist in the second (right) argument, whether or not that value exists in the first (left) argument.\n`outerjoin` : the output contains rows for values of the key that exist in any of the passed data frames. `semijoin` : Like an inner join, but output is restricted to columns from the first (left) argument.","2. In a nutshell: the relational \"join\" operation is simply the above Cartesian product followed by a filtering operation. Generally, the filtering operation will depend on information coming from  both input data sets - for example, that the values in a particular column must match exactly.\n(Any filtering that depends only on information from one input table can be done more efficiently  before the join operation).","3. Creates a collection if groups labelled by `lkey(l)` where each group contains elements `f(l, r)` which satisfy `comparison(lkey(l), rkey(r))` . If there are no matches, the group is still created (with an empty collection).\nThis operation shares some similarities with an SQL left outer join.\n```julia-repl julia> leftgroupjoin(iseven, iseven, tuple, ==, [1,2,3,4], [0,1,2])\nDictionary{Bool,Array{Tuple{Int64,Int64},1}} with 2 entries:\n  false │ Tuple{Int64,Int64}[(1, 1), (3, 1)]\n  true  │ Tuple{Int64,Int64}[(2, 0), (2, 2), (4, 0), (4, 2)]```","4. julia>   @chain   db_table ( db ,   :df_mem )   begin \n         @rename ( new_name   =   percent ) \n         @collect \n         end \n 10×4 DataFrame \n  Row │ id       groups   value   new_name  \n      │ String?  String?  Int64?  Float64?  \n ─────┼──────────────────────────────────── \n    1 │ AA       bb            1       0.1 \n    2 │ AB       aa            2       0.2\nsource #  `TidierDB.@right_join` —  Macro . ```julia @right_join ( sql_query ,   join_table ,   new_table_col ,   orignal_table_col )```\nPerform a right join between two SQL queries based on a specified condition.  This syntax here is slightly different than TidierData.jl, however, because  SQL does not drop the joining column, for the metadata storage, it is  preferrable for the names to be different Arguments `sql_query` : The primary SQL query to operate on.","5. `outerjoin` : the output contains rows for values of the key that exist in any of the passed data frames. `semijoin` : Like an inner join, but output is restricted to columns from the first (left) argument.\n`antijoin` : The output contains rows for values of the key that exist in the first (left) but not the second (right) argument. As with `semijoin` , output is restricted to columns from the first (left) argument. `crossjoin` : The output is the cartesian product of rows from all passed data frames. See  the Wikipedia page on SQL joins for more information.\nHere are examples of different kinds of join:"]},{"average_distance":0.3224891774891775,"minimum_distance":0.0,"question":"Why are tidy expressions considered valid by Julia in `Tidier.jl`?","source":"https://tidierorg.github.io/Tidier.jl/stable/ - Home/What is Tidier.jl? ¤","distance_scores":[0.0,0.0,0.3916666666666667,0.6103896103896104,0.6103896103896104],"context":"The reason that  tidy expressions are considered valid by Julia in `Tidier.jl` is\nbecause they are implemented using macros. Macros \"capture\" the\nexpressions they are given, and then they can modify those expressions\nbefore evaluating them.","answer":"Tidy expressions are considered valid by Julia in `Tidier.jl` because they are implemented using macros. Macros capture the expressions and can modify them before evaluating them.","retrieved_contexts":["1. To handle this using idiomatic\nJulia, `DataFrames.jl` introduces a mini-language that relies heavily\non the creation of anonymous functions, with explicit directional\npairs syntax using a `source => function => destination` syntax. While\nthis is quite elegant, it can be verbose.\n`TidierData.jl` aims to\nreduce this complexity by exposing an R-like syntax, which is then\nconverted into valid `DataFrames.jl` code. The reason that  tidy expressions are considered valid by Julia in `TidierData.jl` is\nbecause they are implemented using macros. Macros \"capture\" the\nexpressions they are given, and then they can modify those expressions\nbefore evaluating them.\nFor consistency, all top-level `dplyr` functions\nare implemented as macros (whether or not a macro is truly needed), and\nall \"helper\" functions (used inside of those top-level functions) are\nimplemented as functions or pseudo-functions (functions which only exist\nthrough modification of the abstract syntax tree).","2. To handle this using idiomatic\nJulia, `DataFrames.jl` introduces a mini-language that relies heavily\non the creation of anonymous functions, with explicit directional\npairs syntax using a `source => function => destination` syntax. While\nthis is quite elegant, it can be verbose.\n`TidierData.jl` aims to\nreduce this complexity by exposing an R-like syntax, which is then\nconverted into valid `DataFrames.jl` code. The reason that  tidy expressions are considered valid by Julia in `TidierData.jl` is\nbecause they are implemented using macros. Macros \"capture\" the\nexpressions they are given, and then they can modify those expressions\nbefore evaluating them.\nFor consistency, all top-level `dplyr` functions\nare implemented as macros (whether or not a macro is truly needed), and\nall \"helper\" functions (used inside of those top-level functions) are\nimplemented as functions or pseudo-functions (functions which only exist\nthrough modification of the abstract syntax tree).","3. When referring to column names, TidierData.jl is a bit unusual for a Julia package in that it does not use symbols.\nThis is because TidierData.jl uses  tidy expressions , which in R lingo equates to a style of programming referred to as \"non-standard evaluation.\" If you are creating a new column `a` containing a value that is the mean of column `b` , you would simply write `a = mean(b)` .\nHowever, there may be times when you wish to create or refer to a column containing a space in it. Let's start by creating some column names containing a space in their name. ```julia using   TidierData \n\n df   =   DataFrame ( var \"my name\"   =   [ \"Ada\" ,   \"Twist\" ], \n                 var \"my age\"   =   [ 40 ,   50 ])``` 2×2 DataFrame Row my name my age","4. Home   Home   Table of contents     What is TidierData.jl?    Installation    What macros and functions does TidierData.jl support?    Example    What’s new    What's missing\nWhat macros and functions does TidierData.jl support?","5. Home   Home   Table of contents     What is TidierData.jl?    Installation    What macros and functions does TidierData.jl support?    Example    What’s new    What's missing\nWhat macros and functions does TidierData.jl support?"]},{"average_distance":0.3414558558558559,"minimum_distance":0.0,"question":"How does `@pivot_wider()` differ from `@pivot_longer()` in terms of argument requirements?","source":"https://tidierorg.github.io/Tidier.jl/stable/examples/generated/UserGuide/pivots - Pivoting/@pivot_longer() ¤","distance_scores":[0.0,0.3866666666666667,0.44594594594594594,0.544,0.33066666666666666],"context":"Now, let's transform this wide dataset into the longer form. Unlike `@pivot_wider()` , where providing the `names_from` and `values_from` arguments is required, the only item that's required in `@pivot_wider()` is a set of columns to pivot. The `names_to` and `values_to` arguments are optional, and if not provided, they will default to \"variable\" and \"value\", respectively.","answer":"In `@pivot_wider()`, providing the `names_from` and `values_from` arguments is required, whereas in `@pivot_longer()`, the only required item is a set of columns to pivot. The `names_to` and `values_to` arguments in `@pivot_longer()` are optional and default to 'variable' and 'value' if not provided.","retrieved_contexts":["1. For calculating summary statistics (e.g., mean) by groups, or for plotting purposes, DataFrames often need to be converted to their longer form. For this, we can use `@pivot_longer` . First, let's start with a \"wide\" DataFrame. ```julia df_wide   =   DataFrame ( id   =   [ 1 ,   2 ],   A   =   [ 1 ,   3 ],   B   =   [ 2 ,   4 ])``` 2×3 DataFrame Row id A\nNow, let's transform this wide dataset into the longer form. Unlike `@pivot_wider()` , where providing the `names_from` and `values_from` arguments is required, the only item that's required in `@pivot_wider()` is a set of columns to pivot. The `names_to` and `values_to` arguments are optional, and if not provided, they will default to \"variable\" and \"value\", respectively.\nWe can recreate the original long dataset by doing the following. Multiple columns must be provided using selection syntax or a selection helper. Tuples containing multiple columns are not yet supported. ```julia @pivot_longer ( df_wide ,   A : B )``` 4×3 DataFrame Row id variable value Int64 String Int64 1 1 A 1 2 2","2. 3 4 2 B 4 To make this dataset wider, we can do the following: ```julia @pivot_wider ( df_long ,   names_from   =   variable ,   values_from   =   value )``` 2×3 DataFrame Row id A B Int64 Int64? Int64? 1 1 1 2 2 2 3 4\nIn `@pivot_wider()` , both the `names_from` and `values_from` arguments are required. `@pivot_wider()` also supports string values for the `names_from` and `values_from` arguments. ```julia @pivot_wider ( df_long ,   names_from   =   \"variable\" ,   values_from   =   \"value\" )``` 2×3 DataFrame Row id A B Int64 Int64? Int64? 1 1 1","3. TidierData.jl   Pivoting       Initializing search    TidierData.jl\nPivoting   Pivoting   Table of contents     @pivot_wider()    @pivot_longer()","4. Pivoting a dataset is needed when information sitting inside of cell values needs to be converted into column names (to make the dataset wider) or vice verse (to make the dataset longer). Either action can be referred to as \"reshaping\" a dataset, and various frameworks refer to the actions as unstacking/stacking or spreading/gathering.\nIn R's tidyverse, these actions are referred to as pivoting, where the two accompanying actions are `@pivot_wider()` and `@pivot_longer()` .","5. Added `@distinct()` . It behaves slightly differently from dplyr when provided arguments in that it returns all columns, not just the selected ones. Added support for `n()` and `row_number()` . Added support for negative selection helper functions (e.g., `-contains(\"a\")` ). Added support for negative selection using `!` (e.g., `!a` , `!(a:b)` , `!contains(\"a\")` ).\nIn `@pivot_longer()` , the `names_to` and `values_to` arguments now also support strings (in addition to bare unquoted names). In `@pivot_wider()` , the `names_from` and `values_from` arguments now also support strings (in addition to bare unquoted names).\nBug fix: `@mutate(a = 1)` or any scalar previously errored because the `1` was being wrapped inside a `QuoteNode` . Now, 1 is correctly broadcasted. Bug fix: `@slice(df, 1,2,1)` previously only returned rows 1 and 2 only (and not 1 again). `@slice(df, 1,2,1)` now returns rows 1, 2, and 1 again. Bug fix: added `repeat()` to the do-not-vectorize list."]},{"average_distance":0.3592307692307693,"minimum_distance":0.28846153846153844,"question":"What is the design philosophy of Tidier.jl regarding the use of scalar or tuple for multiple value arguments?","source":"https://tidierorg.github.io/Tidier.jl/stable - Home/What is Tidier.jl? ¤","distance_scores":[0.3384615384615385,0.32307692307692304,0.42307692307692313,0.42307692307692313,0.28846153846153844],"context":"The design philosophy in `Tidier.jl` is that the user should feel free to provide a scalar or a tuple as they see fit anytime multiple values are considered valid for a given argument, such as in `across()` , and `Tidier.jl` will figure out how to dispatch it.","answer":"The design philosophy in Tidier.jl is that the user should feel free to provide a scalar or a tuple as they see fit anytime multiple values are considered valid for a given argument, such as in `across()`, and Tidier.jl will figure out how to dispatch it.","retrieved_contexts":["1. While you always have the option to intermix Tidier.jl code with DataFrames.jl code, Tidier.jl strives for completeness – there should never be a requirement to fall back to DataFrames.jl for any kind of data analysis task.\nTidier.jl also focuses on conciseness. This shows up most readily in two ways: the use of bare column names, and an approach to auto-vectorizing code.\nBare column names: If you are referring to a column named `a` , you can simply refer to it as `a` in Tidier.jl. You are essentially referring to `a` as if it was within an anonymous function, where the variable `a` was mapped to the column `a` in the data frame.","2. A number of macro-based data analysis packages have emerged as extensions of DataFrames.jl to make data analysis syntax less verbose, including DataFramesMeta.jl, Query.jl, and DataFrameMacros.jl. All of these packages have their strengths, and each of these served as an inspiration towards the creation of Tidier.jl.\nWhat sets Tidier.jl apart is that it borrows the design of the tried-and-widely-adopted tidyverse and brings it to Julia. Our goal is to make data analysis code as easy and readable as possible.\nIn our view, the reason you should use Tidier.jl is because of the richness, consistency, and thoroughness of the design made possible by bringing together two powerful tools: DataFrames.jl and the tidyverse. In Tidier.jl, nearly every possible transformation on data frames (e.g., aggregating, pivoting, nesting, and joining) can be accomplished using a consistent syntax.","3. Julia has a data structure called  tuple . They are really  special in Julia because they are often used in relation to functions. Since functions are an important feature in Julia, every Julia user should know the basics of tuples.\nA tuple is a  fixed-length container that can hold multiple different types . A tuple is an  immutable object , meaning that it cannot be modified after instantiation. To construct a tuple, use parentheses `()` to delimit the beginning and end, along with commas `,` as delimiters between values: ```julia my_tuple = (1, 3.14, \"Julia\")``` ```julia (1, 3.14, \"Julia\")```","4. Julia has a data structure called  tuple . They are really  special in Julia because they are often used in relation to functions. Since functions are an important feature in Julia, every Julia user should know the basics of tuples.\nA tuple is a  fixed-length container that can hold multiple different types . A tuple is an  immutable object , meaning that it cannot be modified after instantiation. To construct a tuple, use parentheses `()` to delimit the beginning and end, along with commas `,` as delimiters between values: ```julia my_tuple = (1, 3.14, \"Julia\")``` ```julia (1, 3.14, \"Julia\")```","5. If you're happy with the R tidyverse, then there's no imminent reason to switch to using Tidier.jl. While DataFrames.jl (the package on which TidierData.jl depends)  is faster than R's dplyr and tidyr on benchmarks , there are other faster backends in R that allow for the use of tidyverse syntax with better speed (e.g., dtplyr, tidytable, tidypolars).\nThe primary reason to consider using Tidier.jl is the value proposition of using Julia itself. Julia has many similarities to R (e.g., interactive coding in a console, functional style, multiple dispatch, dynamic data types), but unlike R, Julia is automatically compiled (to LLVM) before it runs.\nThis means that certain compiler optimations, which are normally only possible in more verbose languages like C/C++ become available to Julia. There are a number of situations in R where the end-user is able to write fast R code as a direct result of C++ being used on the backend (e.g., through the use of the Rcpp package)."]},{"average_distance":0.397289972899729,"minimum_distance":0.0,"question":"What is the main goal of the Tidier.jl package and how does it differ from other Julia meta-packages for DataFrame manipulation?","source":"https://tidierorg.github.io/Tidier.jl/stable/ - Home/What is Tidier.jl? ¤","distance_scores":[0.5745257452574526,0.5745257452574526,0.3875338753387534,0.44986449864498645,0.0],"context":"Whereas other meta-packages introduce Julia-centric idioms for working with\nDataFrames, this package’s goal is to reimplement parts of tidyverse\nin Julia. This means that `Tidier.jl` uses  tidy expressions as opposed\nto idiomatic Julia expressions. An example of a tidy expression is `a = mean(b)` . In Julia, `a` and `b` are variables and are thus \"eagerly\"\nevaluated.","answer":"The main goal of the Tidier.jl package is to reimplement parts of tidyverse in Julia, using tidy expressions like `a = mean(b)` instead of idiomatic Julia expressions. In contrast to other Julia meta-packages that introduce Julia-centric idioms for working with DataFrames, Tidier.jl focuses on utilizing tidy expressions, even though in Julia, variables like `a` and `b` are eagerly evaluated.","retrieved_contexts":["1. TidierData.jl is a 100% Julia implementation of the dplyr and tidyr R packages. Powered by the DataFrames.jl package and Julia’s extensive meta-programming capabilities, TidierData.jl is an R user’s love letter to data analysis in Julia. `TidierData.jl` has two goals, which differentiate it from other data analysis meta-packages in Julia:\nStick as closely to tidyverse syntax as possible.","2. TidierData.jl is a 100% Julia implementation of the dplyr and tidyr R packages. Powered by the DataFrames.jl package and Julia’s extensive meta-programming capabilities, TidierData.jl is an R user’s love letter to data analysis in Julia. `TidierData.jl` has two goals, which differentiate it from other data analysis meta-packages in Julia:\nStick as closely to tidyverse syntax as possible.","3. A number of macro-based data analysis packages have emerged as extensions of DataFrames.jl to make data analysis syntax less verbose, including DataFramesMeta.jl, Query.jl, and DataFrameMacros.jl. All of these packages have their strengths, and each of these served as an inspiration towards the creation of Tidier.jl.\nWhat sets Tidier.jl apart is that it borrows the design of the tried-and-widely-adopted tidyverse and brings it to Julia. Our goal is to make data analysis code as easy and readable as possible.\nIn our view, the reason you should use Tidier.jl is because of the richness, consistency, and thoroughness of the design made possible by bringing together two powerful tools: DataFrames.jl and the tidyverse. In Tidier.jl, nearly every possible transformation on data frames (e.g., aggregating, pivoting, nesting, and joining) can be accomplished using a consistent syntax.","4. What sets Tidier.jl apart is that it borrows the design of the tried-and-widely-adopted tidyverse and brings it to Julia. Our goal is to make data analysis code as easy and readable as possible.\nIn our view, the reason you should use Tidier.jl is because of the richness, consistency, and thoroughness of the design made possible by bringing together two powerful tools: DataFrames.jl and the tidyverse. In Tidier.jl, nearly every possible transformation on data frames (e.g., aggregating, pivoting, nesting, and joining) can be accomplished using a consistent syntax.\nWhile you always have the option to intermix Tidier.jl code with DataFrames.jl code, Tidier.jl strives for completeness – there should never be a requirement to fall back to DataFrames.jl for any kind of data analysis task.","5. Stick as closely to tidyverse syntax as possible.\nWhereas other meta-packages introduce Julia-centric idioms for working with\nDataFrames, this package’s goal is to reimplement parts of tidyverse\nin Julia. This means that `TidierData.jl` uses  tidy expressions as opposed\nto idiomatic Julia expressions. An example of a tidy expression is `a = mean(b)` . In Julia, `a` and `b` are variables and are thus \"eagerly\"\nevaluated.\nThis means that if `b` is merely referring to a column in a\ndata frame and  not an object in the global namespace, then an error\nwill be generated because `b` was not found. In idiomatic Julia, `b` would need to be expressed as a symbol, or `:b` . Even then, `a = mean(:b)` would generate an error because it's not possible to\ncalculate the mean value of a symbol."]},{"average_distance":0.4703488372093023,"minimum_distance":0.37790697674418605,"question":"In Julia, how are the functions 'across(a, mean)' and 'across((a, b), mean)' dispatched differently, and why might this be confusing to R users?","source":"https://tidierorg.github.io/Tidier.jl/stable/ - Home/What is Tidier.jl? ¤","distance_scores":[0.5843023255813953,0.37790697674418605,0.41860465116279066,0.41860465116279066,0.5523255813953488],"context":"In Julia, the function `across(a, mean)` is dispatched differently than `across((a, b), mean)` . The first argument in the first instance above is treated as a scalar, whereas the second instance is treated as a tuple. This can be very confusing to R users because `1 == c(1)` is `TRUE` in R, whereas in Julia `1 == (1,)` evaluates to `false` .","answer":"In Julia, 'across(a, mean)' is dispatched by treating the first argument 'a' as a scalar, while 'across((a, b), mean)' treats the first argument '(a, b)' as a tuple. This can be confusing to R users because in R, '1 == c(1)' evaluates to TRUE, but in Julia, '1 == (1,)' evaluates to false.","retrieved_contexts":["1. Note: when using `across()` , anonymous functions are not vectorized. This is intentional to allow users to specify their function exactly as desired. ```julia @chain   df   begin \n    @mutate ( across ( !! myvar ,   x   ->   x   .+   1 )) \n    @rename ( d   =   b_function ) \n end``` 10×4 DataFrame Row a b c d String Int64 Int64\nInt64 1 a 1 11 2 2 a 1 12 2 3 b 1 13 2 4 b 2 14 3 5 c 2 15 3 6 c 2 16 3 7 d 3 17 4 8 d 3 18 4 9 e 3 19 4 10 e 4 20 5","2. Broadcasting trips up many R users switching to Julia because R users are used to most functions being vectorized. `TidierData.jl` currently uses a lookup table to decide which functions  not to vectorize; all other functions are automatically vectorized. Read the documentation page on \"Autovectorization\" to read about how this works, and how to override the defaults.\nAn example of where this issue commonly causes errors is when centering a variable. To create a new column `a` that centers the column `b` , `TidierData.jl` lets you simply write `a = b - mean(b)` exactly as you would in R.\nThis works because `TidierData.jl` knows to  not vectorize `mean()` while also recognizing that `-`  should be vectorized such that this expression is rewritten in `DataFrames.jl` as `:b => (b -> b .- mean(b)) => :a` . For any user-defined function that you want to \"mark\" as being non-vectorized, you can prefix it with a `~` .","3. \"code\": Defaults to `false` . If set to `true` , this option displays the DataFrames.jl code generated by the TidierData.jl package. It is useful for debugging whether errors are introduced by TidierData.jl's generated code. Arguments `option` : \"code\" `value` : `true` or `false` source #  `TidierData.across` —  Method .\n```julia across ( variable [ s ],   function [ s ])``` Apply functions to multiple variables. If specifying multiple variables or functions, surround them with parentheses so that they are recognized as a tuple. This function should only be called inside of TidierData.jl macros. Arguments\n`variable[s]` : An unquoted variable, or if multiple, an unquoted tuple of variables. `function[s]` : A function, or if multiple, a tuple of functions. Examples","4. \"code\": Defaults to `false` . If set to `true` , this option displays the DataFrames.jl code generated by the TidierData.jl package. It is useful for debugging whether errors are introduced by TidierData.jl's generated code. Arguments `option` : \"code\" `value` : `true` or `false` source #  `TidierData.across` —  Method .\n```julia across ( variable [ s ],   function [ s ])``` Apply functions to multiple variables. If specifying multiple variables or functions, surround them with parentheses so that they are recognized as a tuple. This function should only be called inside of TidierData.jl macros. Arguments\n`variable[s]` : An unquoted variable, or if multiple, an unquoted tuple of variables. `function[s]` : A function, or if multiple, a tuple of functions. Examples","5. `across()` is a helper function that is typically used inside `@mutate()` or `@summarize` to operate on multiple columns and/or multiple functions. Notice that `across()` accepts two arguments, a set of variables and a set of functions.\nIf providing multiple variables or functions, these should be provided as a tuple – in other words, wrapped in parentheses and separated by commas."]}]